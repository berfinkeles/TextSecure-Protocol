# -*- coding: utf-8 -*-
"""Phase 3 .ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nSuJqFOOaUydJcGqEOcVBvT2zUe2CoCM
"""

#pips
!pip install ecpy
!pip install pycryptodome
!pip install Crypto

import math
import timeit
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, SHA256, HMAC
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random.random import randint
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import hashlib, hmac, binascii
import json
API_URL = 'http://cryptlygos.pythonanywhere.com'

stuID =  26714  
stuID_B = 18007


#setup phase
curve = Curve.get_curve('secp256k1')
P= curve.generator
p = curve.field
n = curve.order 
a = curve.a
b = curve.b

def KeyGeneration(P,n): 
  #S_a = Random.random.randint(1,n-1)
  S_a = random.randint(1, n-1) #long term private key
  Q = S_a * P #public key
  return Q, S_a

def SignatureGeneration(P,n, message, S_a): 
  k = Random.random.randint(1,n-2) 
  R = k*P 
  r = R.x % n 
  message = str(message)
  #print(message)
  message = message.encode()
  r_bytes = r.to_bytes((r.bit_length()+7) // 8 , 'big')
  message = message + r_bytes 
  sha = SHA3_256.new(message) 
  h= int.from_bytes(sha.digest(), byteorder='big') % n
  s = pow(S_a * h + k, 1 ,n)
  return h, s


#create a long term key
QCli_long = Point(0xb219ee212792868ba9b97382a55fb6fc799b157265299126ceb7fcab45d42c01 , 0x7626e4953d5c6c388b7652d4b18d37a43333b0cc940d4f6ff0ac4078fa52cf27,curve)
sCli_long = 37184446026316359147926179065697345777863529595040509000128250686640201848774        #private
h, s = SignatureGeneration(P,n, stuID, sCli_long)

#ephemeral keys of stuID
s_a = [101351320767090271562867466957102108742860664709300212827494765318877655491494, 109159318710004036492926332497062845090021450893665360163664477019229555834874, 18749929752288209268443215074561536849133021585475233708160580130825937442781, 71866738747425502112220899867167146556048911867062017739672040456463053158921, 103174885383459299506417017097214074099600345302621674973643355842989986932290, 25954407591895656099032562299641009764398188588989988372346328705519156046438, 51718037375371369693545069483840669927533304045892216441892151430057796596722, 92972915100942609367312407591701897139702584624926461972073372687654192358458, 7418398250873805975482706632834446739745130668424855354015398318246606848553, 7148718534008419876292536399711436311346152317943082968629403689672283105680]

Q_a = [ Point(0x916c035adefca47a47ae49533c600cd1c99cd85db25ae82f1a9c4c55d7e6767f , 0x97146dbdf7eaf2d786daee19197ab57ea714c4e6720fb10e95b8c8ad75ff213a,curve),
        Point(0x7a13fb7735179a6de70987a8886ee22dc190fda40924b26d14752100ba0137c4 , 0x980ea9390a89f052b56b7264536596630d28b645bc8b7f3486fc9b509d64782d,curve),
        Point(0xe3c792f939ce6875b5ded4bef4e4be6ace4e6084321dd38fad948a2b02385623 , 0xf341c37a6c72c9d0bb7640a6def7f471f54d406153986098bf9a83a479627518,curve),
        Point(0x806eaf97d6b06407a606b8b686f77e3fe3354466c709a74e2a2fa571d850a120 , 0x475ba73e4bb5439139fef796dbc86321f25f67a3231826a523548fb623508cff,curve),
        Point(0x9492b979078bb763c362e765da6e4bb83c8dc3a39332002e986cc6fbe4976345 , 0x3e2484bca59d01316c3b0fdb178feb4b9878b2cb31b8739b8e86043cdc961c46,curve),
        Point(0xa8e3b25d2ad0bf52b30d6db5cf660ac74c6ec1f521dd995e3b82bae13f20f1ae , 0x3761b701d77842db4b059392f89ed49f646da0bf164d82dd138bed6c3b0e23d6,curve),
        Point(0x1983045e0f3dcf296b7bea844012d0aba72aebecb024d33eae15357bebb6da7c , 0x6bbd6831a1d474e3f9a647dd48412106b511c491f1564e101075b6480f711679,curve),
        Point(0xb5ab762412561293715563f97b22e50015aa158f20eb6b06ffa08d5fd35e4ae5 , 0xfba6269fb1ce19fb932eae359f69ef7cd6fb08ed9941855016583cf40314bb5a,curve),
        Point(0xfaa5e707f38de6eef9eb4a48b7514a763cb0d3dfd80dd6d7bf0408dd17064e2a , 0x4b67c6a1d63e877e07044c6d6a36c554666a862b487d9c6b68b1833daca750f9,curve),
        Point(0xb244ed3ec56f9e9e3ce3e17fe15e2207dfd6c993ecfe58e5de412c2a87a5ca0 , 0x878fa53c3f60192a5927745562058ce28d67c83e0bd68be0b2abdd7cfcf66596,curve) ]


####Register Long Term Key
'''
#s, h = SignGen(str(stuID).encode(), curve, sCli_long)
mes = {'ID':stuID, 'H': h, 'S': s, 'LKEY.X': QCli_long.x, 'LKEY.Y': QCli_long.y}
response = requests.put('{}/{}'.format(API_URL, "RegLongRqst"), json = mes)
print(response.json())

code = int(input())

mes = {'ID':26714, 'CODE': code}
response = requests.put('{}/{}'.format(API_URL, "RegLong"), json = mes)
print(response.json())

'''




#Check Status
mes = {'ID_A':26714, 'H': h, 'S': s}
response = requests.get('{}/{}'.format(API_URL, "Status"), json = mes)
print("Status ", response.json())


'''
#######SEND EPHEMERAL KEYS TO SERVER ############
for i in range(0, 10):
  #Send Ephemeral keys
  msg = str(Q_a[i].x) + str(Q_a[i].y)
  h , s = SignatureGeneration(P,n,msg,sCli_long)
  ekey = Q_a[i]
  mes = {'ID': stuID, 'KEYID': i , 'QAI.X': ekey.x, 'QAI.Y': ekey.y, 'Si': s, 'Hi': h}
  response = requests.put('{}/{}'.format(API_URL, "SendKey"), json = mes)
  print(response.json())

'''

###############SEND MESSAGE#################
quotes = ['The world is full of lonely people afraid to make the first move.',
              'I don’t like sand. It’s all coarse, and rough, and irritating. And it gets everywhere.',
              'Hate is baggage. Life’s too short to be pissed off all the time. It’s just not worth it.',
              'Well, sir, it’s this rug I have, it really tied the room together.',
              'Love is like taking a dump, Butters. Sometimes it works itself out. But sometimes, you need to give it a nice hard slimy push.']

h, s = SignatureGeneration(P,n, stuID_B, sCli_long)

for k in range(0, len(quotes)):
  ### Get key of the Student B
  mes = {'ID_A': stuID, 'ID_B':stuID_B, 'S': s, 'H': h}
  response = requests.get('{}/{}'.format(API_URL, "ReqKey"), json = mes)
  res = response.json()
  print(res)

  Q_b = Point(int(res['QBJ.x']),int(res['QBJ.y']),curve) #ephemeral key of stuID_B
  i = int(res['i']) #i = stuID's ephemeral key id
  j = int(res['j']) #j = stuID_B's ephemeral key id
 
  if j == 9:
    last_qb = Q_b
  
  if( k > 9):
    Q_b = last_qb
  T = s_a[i]*Q_b
  U = str(T.x) + str(T.y) + 'NoNeedToRunAndHide'
  U = U.encode()
  sha = SHA3_256.new(U) 
  K_enc = sha.digest()
  sha_mac = SHA3_256.new(K_enc)  
  K_mac = sha_mac.digest()
  ###Encryption
  ptext = quotes[k]
  ptext = ptext.encode()
  cipher = AES.new(K_enc, AES.MODE_CTR)
  ctext = cipher.encrypt(ptext)
  HMAC = hmac.new(key = K_mac,msg = ctext,digestmod = hashlib.sha256).digest()
  ctext = cipher.nonce + ctext + HMAC
  ctext = int.from_bytes(ctext, byteorder = 'big')

  ### Send message to student B
  msg = ctext
  mes = {'ID_A': stuID, 'ID_B':stuID_B, 'I': i, 'J':j, 'MSG': msg}
  response = requests.put('{}/{}'.format(API_URL, "SendMsg"), json = mes)
  print(response.json())

####################################
'''
################GET MESSAGE#################

h, s = SignatureGeneration(P,n, stuID, sCli_long)
amount = 13# change amount to the number of messages that is sent 
for j in range(0, amount):
  ## Get your message
  mes = {'ID_A': stuID, 'S': s, 'H': h}
  response = requests.get('{}/{}'.format(API_URL, "ReqMsg_PH3"), json = mes)
  print(response.json())
  if(response.ok): 
    ## Decrypt message
    res = response.json()
    if 'MSG' in res:
      kid = int(res['KEYID'])
      if(kid > 9):
        kid = 9
      q_b = Point(res['QBJ.X'],res['QBJ.Y'],curve)
      T = s_a[int(kid)]*q_b
      U = str(T.x) + str(T.y) + 'NoNeedToRunAndHide'
      U = U.encode()
      sha = SHA3_256.new(U) 
      K_enc = sha.digest()
      sha_mac = SHA3_256.new(K_enc)  
      K_mac = sha_mac.digest()

      #Convert message to bytes
      msg = res['MSG'].to_bytes((res['MSG'].bit_length()+7) // 8 , 'big')
      print("Message retrieved from sender:",msg)
      #Ciphertext part of message
      ctext = msg[8:len(msg)-32]
      print("Ciphertext:",ctext)
      #HMAC part of message
      hmac_ = msg[len(msg)-32:]

      ### HMAC CALCULATION ###
      HMAC = hmac.new(key = K_mac,msg = ctext,digestmod = hashlib.sha256).digest()
      if HMAC == hmac_:
        print("The message is authentic")

      ### DECRYPT ###
      mes = msg[:len(msg)-32]
      cipher = AES.new(K_enc, AES.MODE_CTR, nonce=mes[0:8])
      dtext = cipher.decrypt(mes[8:])
      dtext = dtext.decode()
      print("Message:", dtext)

'''
#################################
'''
#####Reset Ephemeral Keys
h, s = SignatureGeneration(P,n, stuID, sCli_long)
#s, h = SignGen("18007".encode(), curve, sCli_long)
mes = {'ID': stuID, 'S': s, 'H': h}
print(mes)
response = requests.get('{}/{}'.format(API_URL, "RstEKey"), json = mes)
print(response.json())
'''
'''
#####Reset Long Term Key
mes = {'ID': stuID}
response = requests.get('{}/{}'.format(API_URL, "RstLongRqst"), json = mes)
print(response.json())
code = int(input())

mes = {'ID': stuID ,'CODE': code}
response = requests.get('{}/{}'.format(API_URL, "RstLong"), json = mes)
print(response.json())

'''


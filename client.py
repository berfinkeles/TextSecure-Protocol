# -*- coding: utf-8 -*-
"""Client.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/145cuZGG8J4yusm8SEXwqSDiaCTPt654w
"""

#pips
!pip install ecpy
!pip install pycryptodome
!pip install Crypto

import math
import timeit
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Random.random import randint 
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import re
import json
from ecpy.keys import ECPublicKey, ECPrivateKey


API_URL = 'http://cryptlygos.pythonanywhere.com'

stuID = 26714



#HERE CREATE A LONG TERM KEY
def KeyGeneration(P,n): 
  #S_a = Random.random.randint(1,n-1)
  S_a = random.randint(1, n-1) #long term private key
  Q = S_a * P #public key
  return Q, S_a

def SignatureGeneration(P,n, message, S_a): 
  k = Random.random.randint(1,n-2) 
  R = k*P 
  r = R.x % n 
  message = str(message)
  #print(message)
  message = message.encode()
  r_bytes = r.to_bytes((r.bit_length()+7) // 8 , 'big')
  message = message + r_bytes 
  sha = SHA3_256.new(message) 
  h= int.from_bytes(sha.digest(), byteorder='big') % n
  s = pow(S_a * h + k, 1 ,n)
  return h, s

def SignatureVerification(m,s,h,QA,P):
  h = int(h)
  s = int(s)
  m = m.encode()
  V = s*P - h*QA
  v = V.x % n
  v = v.to_bytes((v.bit_length()+7) // 8 , 'big')
  sha = SHA3_256.new(m+v) 
  h_ = int.from_bytes(sha.digest(), byteorder='big') % n
  if h_ == h:
    return True
  else:
    return False

#setup phase
curve = Curve.get_curve('secp256k1')
P= curve.generator
p = curve.field
n = curve.order 
a = curve.a
b = curve.b


#LONG TERM KEY GENERATION
'''
lkey,S_l = KeyGeneration(P,n)
print(lkey)
print(S_l)

h, s = SignatureGeneration(P,n, stuID, S_l)
#print("h: ", h, "s: ", s)
'''


#server's long term key
QSer_long = Point(0xc1bc6c9063b6985fe4b93be9b8f9d9149c353ae83c34a434ac91c85f61ddd1e9 , 0x931bd623cf52ee6009ed3f50f6b4f92c564431306d284be7e97af8e443e69a8c, curve)

#our long term keys
QL = Point(0xcd602c771b7512e3e233244a97bd993a950150e72b6b115d43fafeed64544154 , 0xca9c0a7d7e6e0193cdf91f02189ee30621b2a868b355e733398dd9207df8d256, curve) #public
SL = 23916690957386916066305540047059383688060488564580735175935528151668985032797        #private



# HERE GENERATE A EPHEMERAL KEY 
'''
ekey,S_a = KeyGeneration(P,n)
print("EKEY: " ,ekey)
print("SA: " ,S_a)
'''

#our ephemeral keys
QA = Point(0xdc5c0f988016510a85faf6869195e2b5e7baec639db0f126e38837e37f7e465a , 0xb07b10b84dbe234c09b14b1b767c21c149a5b956198deb74027f23fd3af86a12,curve)
SA = 112445680346675639523149080326210810332692175966651308926487492700235206107637


#Ephemeral key of the server {'SKEY.X': 115387858341009215005049043443742739870807827787720573993258640245878230603604, 'SKEY.Y': 85021174615600057429417835542118953092990743727832975663580255937626798652393}
Q_b = Point(115387858341009215005049043443742739870807827787720573993258640245878230603604,85021174615600057429417835542118953092990743727832975663580255937626798652393,curve) 


ekey = QA

try:
  #RUN REGISTRATION ONLY ONCE
  '''
   #REGISTRATION
  mes = {'ID':stuID, 'h': h, 's': s, 'LKEY.X': lkey.x, 'LKEY.Y': lkey.y}
  response = requests.put('{}/{}'.format(API_URL, "RegStep1"), json = mes)
  if((response.ok) == False): raise Exception(response.json())
  print(response.json())

  print("Enter verification code which is sent to you: ")
  code = int(input())

  mes = {'ID':stuID, 'CODE': code}
  response = requests.put('{}/{}'.format(API_URL, "RegStep3"), json = mes)
  if((response.ok) == False): raise Exception(response.json())
  print(response.json())
  '''
  #STS PROTOCOL
  mes = {'ID': stuID, 'EKEY.X': ekey.x, 'EKEY.Y': ekey.y}
  response = requests.put('{}/{}'.format(API_URL, "STSStep1&2"), json = mes)
  if((response.ok) == False): raise Exception(response.json())
  res=response.json()

  #calculate T,K,U
  T = SA*Q_b
  U = str(T.x) + str(T.y) + 'BeYourselfNoMatterWhatTheySay'
  U = U.encode()
  h = SHA3_256.new(U)
  K = h.digest()

  #Sign Message
  W1 = str(QA.x) + str(QA.y) + str(Q_b.x) + str(Q_b.y)
  Sig_a_h , Sig_a_s = SignatureGeneration(P,n,W1,SL)
  cipher = AES.new(K, AES.MODE_CTR)
  plaintext = 's' + str(Sig_a_s) + 'h' + str(Sig_a_h)
  plaintext = plaintext.encode()

  # Encyption
  Y_1 = cipher.encrypt(plaintext)
  ctext = cipher.nonce + Y_1
  ctext = int.from_bytes(ctext, byteorder = 'big')
  print("Ciphertext of W1:",ctext)

  ###Send encrypted-signed keys and retrive server's signed keys
  mes = {'ID': stuID, 'FINAL MESSAGE': ctext}
  response = requests.put('{}/{}'.format(API_URL, "STSStep4&5"), json = mes)
  if((response.ok) == False): raise Exception(response.json()) 
  ctext1= response.json() 
  print("Server's signed keys: ", ctext1)


  #Decrypt 
  W2 = str(Q_b.x) + str(Q_b.y) + str(QA.x) + str(QA.y)
  S_Cipher = ctext1
  S_CipherBytes = S_Cipher.to_bytes((S_Cipher.bit_length()+7) // 8 , 'big')
  cipher = AES.new(K, AES.MODE_CTR, nonce=S_CipherBytes[0:8])
  dtext = cipher.decrypt(S_CipherBytes[8:])
  print("PLAINEXT OF THE SERVER: ",dtext)
  #verify
  dtext = dtext.decode()
  server_s = dtext[1:dtext.find('h')]
  server_h = dtext[dtext.find('h')+1:]
  print("Verified:",SignatureVerification(W2, server_s, server_h,QSer_long,P))


  #get a message from server for 
  mes = {'ID': stuID}
  response = requests.get('{}/{}'.format(API_URL, "STSStep6"), json = mes)
  ctext2 = response.json()
  print("MESSAGE FROM SERVER: ", ctext2)  



  #Decrypt
  W3 = ctext2
  W3_bytes = W3.to_bytes((W3.bit_length()+7) // 8 , 'big')
  R= W3_bytes[0:8]
  R = int.from_bytes(R, byteorder='big')
  cipher2 = AES.new(K, AES.MODE_CTR , nonce =W3_bytes[0:8])
  ptext = cipher2.decrypt(W3_bytes[8:])
  print("PLAINTEXT OF W3: ", ptext)
  ptext= ptext.decode()
  Rand = ptext[ptext.find('.') +1 : ]
  msg = ptext[ :ptext.find('.')+2]
  print("MESSAGE: ", msg)
  print("RAND: ", Rand)

  #Add 1 to random to create the new message and encrypt it
  Rand1 = int(Rand) +1 
  msg_concat = msg + str(Rand1)
  print("MESSAGE TO SERVER: ", msg_concat)
  msg_concat = msg_concat.encode()
  cipher3 = AES.new(K, AES.MODE_CTR)
  W4_cipher = cipher3.encrypt(msg_concat)
  W4_cipher = cipher3.nonce + W4_cipher
  W4_cipher = int.from_bytes(W4_cipher, byteorder = 'big')
  ct = W4_cipher



  #send the message and get response of the server
  mes = {'ID': stuID, 'ctext': ct}
  response = requests.put('{}/{}'.format(API_URL, "STSStep7&8"), json = mes)
  ctext3 = response.json()
  SUCC = ctext3
  SUCC_byte = SUCC.to_bytes((SUCC.bit_length()+7) // 8 , 'big')
  cipher4 = AES.new(K, AES.MODE_CTR , nonce =SUCC_byte[0:8])
  ptext = cipher4.decrypt(SUCC_byte[8:])
  print("RETURNED MESSAGE FROM SERVER:", ptext)         

except Exception as e:
	print(e)